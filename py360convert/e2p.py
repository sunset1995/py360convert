import numpy as np

from . import utils


def e2p(e_img, fov_deg, u_deg, v_deg, out_hw, in_rot_deg=0, mode="bilinear"):
    """
    e_img:   ndarray in shape of [H, W, *]
    fov_deg: scalar or (scalar, scalar) field of view in degree
    u_deg:   horizon viewing angle in range [-180, 180]
    v_deg:   vertical viewing angle in range [-90, 90]
    """
    if e_img.ndim != 3:
        raise ValueError("e_img must have 3 dimensions.")
    h, w = e_img.shape[:2]

    try:
        h_fov, v_fov = np.deg2rad(fov_deg[0]), np.deg2rad(fov_deg[1])
    except IndexError:
        h_fov = v_fov = np.deg2rad(fov_deg)
    in_rot = in_rot_deg * np.pi / 180

    if mode == "bilinear":
        order = 1
    elif mode == "nearest":
        order = 0
    else:
        raise NotImplementedError("unknown mode")

    u = -u_deg * np.pi / 180
    v = v_deg * np.pi / 180
    xyz = utils.xyzpers(h_fov, v_fov, u, v, out_hw, in_rot)
    uv = utils.xyz2uv(xyz)
    coor_xy = utils.uv2coor(uv, h, w)

    pers_img = np.stack(
        [utils.sample_equirec(e_img[..., i], coor_xy, order=order) for i in range(e_img.shape[2])], axis=-1
    )

    return pers_img
